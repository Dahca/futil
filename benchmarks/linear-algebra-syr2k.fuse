decl alpha: ubit<32>[1];
decl beta: ubit<32>[1];
decl C: ubit<32>[12][12];
decl A: ubit<32>[12][8];
decl B: ubit<32>[12][8];


for (let i: ubit<4> = 0..12) {
  let j: ubit<4> = (0 as ubit<4>);
  while (j <= i) {
    decor "#pragma HLS loop_tripcount min=1 max=12 avg=6"
    let C_i_j: ubit<32> = C[i][j];
    ---
    C[i][j] := C_i_j * beta[(0 as ubit<1>)];

    // Update loop counter
    j := j + (1 as ubit<4>);
  }
  ---
  for (let k: ubit<4> = 0..8) {
    let j2: ubit<4> = (0 as ubit<4>);
    while (j2 <= i) {
      decor "#pragma HLS loop_tripcount min=1 max=12 avg=6"
      let C_i_j2: ubit<32> = C[i][j2];
      let B_i_k: ubit<32> = B[i][k];
      let A_j2_k: ubit<32> = A[j2][k]
      ---
      let tmp0: ubit<32> = A_j2_k * alpha[(0 as ubit<1>)];
      let tmp1: ubit<32> = tmp0 * B_i_k;

      let tmp2 = B[j2][k] * alpha[(0 as ubit<1>)];
      let tmp3 = tmp2 * A[i][k];

      let tmp4 = tmp1 + tmp3;
      C[i][j2] := tmp4 + C_i_j2;
      // C[i][j2] := A_j2_k * alpha[(0 as ubit<1>)] * B_i_k +
      //             B[j2][k] * alpha[(0 as ubit<1>)] * A[i][k] + C_i_j2;
      // Update loop counter
      j2 := j2 + (1 as ubit<4>);
    }
  }
}
